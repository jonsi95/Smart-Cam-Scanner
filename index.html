<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Google site verification -->
  <meta name="google-site-verification" content="9BGaHpsqevRo9JmmEwG2fD_27ZVueRyymfoPkAEz_Ec" />

  <!-- Google tag (gtag.js) -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=G-HKGH8FZZXH"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){ dataLayer.push(arguments); }
    gtag('js', new Date());
    // keep anonymize_ip like your old working setup
    gtag('config', 'G-HKGH8FZZXH', { 'anonymize_ip': true });
  </script>

  <!-- Primary Meta Tags -->
  <title>Smart Cam Scanner – Camera to PDF | Online Document Scanner | Free Image to PDF</title>
  <meta name="title" content="Smart Cam Scanner – Camera to PDF | Online Document Scanner | Free Image to PDF">
  <meta name="description" content="Free online camera-to-PDF tool with smart crop, auto-enhance, adaptive B/W, image merging, multi-format support (JPEG, PNG, WEBP, AVIF, HEIC, HEIF). Simple, fast, secure, no install needed.">
  <meta name="keywords" content="camera to pdf, cam scanner online, free scanner tool, image to pdf, merge images, merge pdf, online document scanner, smart scanner, scan to pdf free, camera scan tool, auto crop scan, heic to pdf, avif to pdf, webp to pdf, best online scanner">
  <meta name="robots" content="index, follow">
  <meta name="language" content="English">
  <meta name="author" content="Smart Cam Scanner">
  <link rel="canonical" href="https://cameratopdf.skycommunics.com/">

  <!-- Icons & PWA -->
  <link rel="icon" type="image/png" href="/icons/icon-192.png">
  <link rel="apple-touch-icon" href="/icons/icon-512.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="theme-color" content="#1a73e8">

  <!-- Open Graph -->
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://cameratopdf.skycommunics.com/">
  <meta property="og:title" content="Smart Cam Scanner – Free Camera to PDF Tool">
  <meta property="og:description" content="Online smart doc scanner with auto crop, B/W mode, image merge, and full image support (JPEG, PNG, WEBP, AVIF, HEIC, HEIF). No installation required.">
  <meta property="og:image" content="https://cameratopdf.skycommunics.com/preview.png">

  <!-- Twitter -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Smart Cam Scanner – Free Camera to PDF Tool">
  <meta name="twitter:description" content="Fast online camera-to-PDF scanner with smart crop, B/W, merge and multi-format support.">
  <meta name="twitter:image" content="https://cameratopdf.skycommunics.com/preview.png">

  <!-- Structured data -->
  <script type="application/ld+json">
  {
    "@context":"https://schema.org",
    "@type":"WebApplication",
    "name":"Smart Cam Scanner",
    "url":"https://cameratopdf.skycommunics.com/",
    "image":"https://cameratopdf.skycommunics.com/preview.png",
    "applicationCategory":"UtilityApplication",
    "operatingSystem":"Android, iOS, Web",
    "description":"Free smart camera-to-PDF scanner with auto crop, adaptive B/W, image merging and support for JPEG, PNG, WEBP, AVIF, HEIC, HEIF formats.",
    "browserRequirements":"Requires JavaScript",
    "offers":{"@type":"Offer","price":"0","priceCurrency":"USD"}
  }
  </script>

  <!-- libs -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/exif-js/2.3.0/exif.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <script src="https://unpkg.com/heic2any/dist/heic2any.min.js"></script>

  <style>
    :root{
      --accent:#21d4fd;
      --accent-2:#1a73e8;
      --danger:#ff3b3b;
      --muted:#6b7280;
      --bg:#eef2ff;
      --line:#ffffff;
      --card:#ffffff;
      --btn-blue:#e9f6ff;
      --btn-size:86px; /* slightly bigger icons */
      --fb-blue: #1877f2;
    }
    *{box-sizing:border-box}
    body{font-family:system-ui,Roboto,Arial;background:linear-gradient(180deg,#eef2ff 0%, #f8fbff 100%);margin:0;padding:18px;color:#202124}
    .page{max-width:980px;margin:0 auto}
    .container{background:var(--card);padding:18px;border-radius:12px;box-shadow:0 6px 30px rgba(0,0,0,0.08);max-width:980px;margin:auto}
    .title-banner{display:flex;align-items:center;gap:14px;padding:14px;border-radius:12px;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,0.08);margin-bottom:12px}
    .title-text h1{margin:0;font-size:20px;font-weight:800}
    .title-text p{margin:2px 0 0;font-size:13px;color:#5f6368}
    /* top controls */
    .top-row{display:flex;gap:12px;align-items:center;margin-top:10px}
    .tool-btn{width:var(--btn-size);height:var(--btn-size);border-radius:12px;background:var(--btn-blue);display:flex;flex-direction:column;align-items:center;justify-content:center;cursor:pointer;border:0;box-shadow:0 6px 18px rgba(33,41,77,0.06);gap:8px;padding:8px}
    .tool-icon{width:40px;height:40px;display:block} /* increased */
    .tool-label{font-size:13px;color:#111;text-align:center}
    .small-btn{padding:10px 14px;border-radius:8px;border:0;cursor:pointer;font-size:14px;font-weight:600}
    #tip{margin-top:12px;color:#444;font-size:14px}
    .thumbs{margin-top:20px;display:flex;flex-wrap:wrap;gap:12px}
    .thumb-box{position:relative;width:120px;background:#000;padding:6px;border-radius:10px}
    .thumb{width:120px;height:150px;object-fit:cover;border-radius:8px;border:2px solid #111;cursor:pointer;display:block;background:#111}
    .thumb-placeholder{width:120px;height:150px;border-radius:8px;background:#111;color:#fff;display:flex;align-items:center;justify-content:center;padding:8px;text-align:center;font-size:12px}
    .remove-btn{position:absolute;right:6px;top:4px;background:transparent;border:0;font-size:20px;color:var(--danger);cursor:pointer;font-weight:900}
    .move-left,.move-right{position:absolute;bottom:6px;background:#111;color:#fff;border:0;padding:6px 8px;border-radius:6px;font-size:14px;font-weight:900;cursor:pointer}
    .move-left{left:6px}
    .move-right{right:6px}
    .actions{margin-top:18px;display:none}
    .actions select{padding:8px;border-radius:8px;font-size:14px}
    /* small global message */
    #globalMsg { margin-top:10px; color:#0b69c8; font-weight:600; display:none; }
    /* spinners */
    .spinner { width:18px;height:18px;border-radius:50%;border:3px solid rgba(0,0,0,0.08);border-top-color:var(--accent); animation:spin 1s linear infinite; display:inline-block; vertical-align:middle; margin-left:8px; }
    .hidden { display:none!important; }
    @keyframes spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }
    /* Crop modal */
    #cropModal{position:fixed;inset:0;background:rgba(0,0,0,0.88);display:none;align-items:center;justify-content:center;z-index:9999}
    #cropBox{background:#fff;padding:12px;border-radius:12px;max-width:95vw;max-height:92vh;overflow:auto}
    .crop-stage{position:relative;display:inline-block;background:#000;border-radius:8px;padding:8px;touch-action:none}
    #cropImage{display:block;max-width:82vw;max-height:72vh;background:#000}
    #cropSVG{position:absolute;left:0;top:0;pointer-events:auto;overflow:visible}
    .corner-rect{fill:white;stroke:var(--accent);stroke-width:3;cursor:grab;opacity:1}
    .crop-line{stroke:var(--line);stroke-width:2;pointer-events:auto}
    .crop-polygon{fill:rgba(255,255,255,0.06);stroke:rgba(255,255,255,0.95);stroke-width:2;pointer-events:auto}
    .crop-toolbar{margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;align-items:center}
    .bw-control{display:flex;align-items:center;gap:8px}
    .small-note{font-size:13px;color:#666;margin-top:8px}
    footer{max-width:980px;margin:18px auto 40px;padding:12px;color:#666;font-size:13px;text-align:center}
    footer a{color:var(--accent)}
    .fb-feedback{display:inline-block;padding:8px 12px;border-radius:8px;background:var(--fb-blue);color:#fff;text-decoration:none}
    .badge-row{display:flex;gap:8px;flex-wrap:wrap;margin-top:8px}
    .badge{padding:6px 10px;border-radius:999px;background:#f3f6ff;border:1px solid #e6f0ff;color:#0b69c8;font-weight:700;font-size:13px}
    @media(max-width:600px){
      :root{--btn-size:78px}
      .tool-label{font-size:11px}
      .tool-icon{width:34px;height:34px}
      .thumb{width:98px;height:130px}
      .thumb-placeholder{width:98px;height:130px}
    }
  </style>
</head>

<body>
  <div style="max-width:980px;margin:auto;padding:0 18px 12px;">
    <button id="installBtn" style="display:none;padding:10px 16px;background:#1a73e8;color:white;border:0;border-radius:8px;font-size:14px;font-weight:600;cursor:pointer;">Install App</button>
  </div>

  <div class="container" role="main" aria-labelledby="appTitle">
    <!-- Title banner: google-drive style -->
    <div class="title-banner" role="banner">
      <div class="title-text">
        <h1 id="appTitle">Smart Cam Scanner</h1>
        <p>input supported: jpeg, png, webp, avif, heic/heif — output support: pdf, jpeg, png, webp (browser-dependent)</p>
      </div>
    </div>

    <!-- top controls -->
    <div class="top-row" role="toolbar" aria-label="Tools">
      <label id="cameraBtn" class="tool-btn" title="Open device camera" tabindex="0">
        <!-- larger camera icon -->
        <svg class="tool-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <g fill="none" fill-rule="evenodd">
            <rect x="2" y="6" width="20" height="12" rx="2.5" fill="#0ea5ff"/>
            <circle cx="12" cy="12" r="3.4" fill="#fff"/>
            <rect x="6" y="4" width="3" height="2" rx="0.8" fill="#7dd3fc"/>
          </g>
        </svg>
        <!-- camera: use image/* with capture to open camera directly on supporting devices -->
        <input id="nativeCam" type="file" accept="image/*,image/heic,image/heif,image/avif" capture="environment" multiple hidden>
        <div class="tool-label">Camera</div>
      </label>

      <label id="galleryBtn" class="tool-btn" title="Choose from gallery" tabindex="0">
        <svg class="tool-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <rect x="3" y="3" width="18" height="18" rx="3" fill="#7c3aed"/>
          <path d="M7 15l3-4 4 5 3-3 3 4H7z" fill="#fff"/>
        </svg>
        <!-- gallery: image/* to open gallery picker on mobile -->
        <input id="pick" type="file" accept="image/*,image/heic,image/heif,image/avif" multiple hidden>
        <div class="tool-label">Gallery</div>
      </label>

      <button id="moreTools" class="tool-btn" title="More tools" aria-haspopup="true">
        <!-- changed to a gear/wrench icon for clarity -->
        <svg class="tool-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg">
          <path fill="#0b69c8" d="M19.14 12.94a7.48 7.48 0 0 0 .05-.94 7.48 7.48 0 0 0-.05-.94l2.03-1.58a.5.5 0 0 0 .12-.63l-1.92-3.32a.5.5 0 0 0-.6-.22l-2.39.96a7.25 7.25 0 0 0-1.63-.94l-.36-2.54A.5.5 0 0 0 14.5 0h-4a.5.5 0 0 0-.49.42l-.36 2.54c-.57.22-1.11.52-1.63.94l-2.39-.96a.5.5 0 0 0-.6.22L1.41 8.43a.5.5 0 0 0 .12.63l2.03 1.58c-.03.31-.03.62 0 .94L1.53 14.1a.5.5 0 0 0-.12.63l1.92 3.32c.13.22.39.32.62.22l2.39-.96c.52.42 1.06.72 1.63.94l.36 2.54c.05.28.28.42.49.42h4c.21 0 .44-.14.49-.42l.36-2.54c.57-.22 1.11-.52 1.63-.94l2.39.96c.23.09.49 0 .62-.22l1.92-3.32a.5.5 0 0 0-.12-.63l-2.03-1.58zM12 15.5A3.5 3.5 0 1 1 12 8.5a3.5 3.5 0 0 1 0 7z"/>
        </svg>
        <div class="tool-label">More Tools</div>
      </button>

      <button id="clearAll" class="tool-btn" title="Clear all">
        <svg class="tool-icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path fill="#c0392b" d="M6 7h12v12a2 2 0 0 1-2 2H8a2 2 0 0 1-2-2z"/><path fill="#fff" d="M9 10h6v2H9zM9 13h6v2H9z"/></svg>
        <div class="tool-label">Clear All</div>
      </button>
    </div>

    <div id="tip">Tap Camera to take pictures or Gallery to choose files. Use both together to add more images.</div>
    <div id="globalMsg"></div>

    <div id="thumbs" class="thumbs" aria-live="polite"></div>

    <div id="actions" class="actions" role="region" aria-label="Actions">
      <button id="savePDF" class="small-btn" style="background:var(--accent);color:white">Save PDF <span id="spinnerSavePDF" class="spinner hidden"></span></button>
      <div style="margin-top:8px">
        <label>Save as:</label>
        <!-- removed AVIF output option as requested -->
        <select id="imgFormat"><option value="jpeg">JPEG</option><option value="png">PNG</option><option value="webp">WEBP</option></select>
      </div>
      <div style="margin-top:10px;display:flex;gap:10px;flex-wrap:wrap;">
        <button id="saveImages" class="small-btn" style="background:#0ea5ff;color:white">Save Images <span id="spinnerSaveImages" class="spinner hidden"></span></button>
        <button id="saveMerged" class="small-btn" style="background:#10b981;color:white">Merge All <span id="spinnerMerge" class="spinner hidden"></span></button>
      </div>
    </div>

  </div>

  <!-- Crop modal -->
  <div id="cropModal" aria-hidden="true">
    <div id="cropBox">
      <div class="crop-stage" id="cropStage">
        <img id="cropImage" alt="preview"/>
        <svg id="cropSVG" xmlns="http://www.w3.org/2000/svg"></svg>
      </div>

      <div class="crop-toolbar">
        <button id="cropToggle" class="small-btn" style="background:black;color:white">Crop</button>
        <button id="rotateBtn" class="small-btn" style="background:#374151;color:white">Rotate ⟳</button>
        <button id="applyGray" class="small-btn" style="background:#374151;color:white">Grayscale</button>
        <button id="applyBW" class="small-btn" style="background:#111;color:white">B/W</button>

        <div class="bw-control" title="Adjust B/W darkness">
          <label style="font-size:13px;color:#444">B/W</label>
          <input id="bwRange" type="range" min="0" max="100" value="50" step="1" style="width:160px">
        </div>

        <button id="origBtn" class="small-btn" style="background:#6b7280;color:white">Original</button>
        <button id="saveBtn" class="small-btn" style="background:var(--accent);color:white">Save <span id="spinnerSaveCrop" class="spinner hidden"></span></button>
        <button id="cropCancel" class="small-btn" style="background:var(--danger);color:white">Cancel</button>
      </div>

      <div class="small-note">Tip: Click a thumbnail to edit — crop/filters/rotate. Use the B/W slider to adjust darkness before saving.</div>
    </div>
  </div>

  <!-- README / How-to -->
  <section id="readme" style="padding:20px; max-width:980px;margin:18px auto; font-size:14px; color:#444; background:#fff;border-radius:12px;box-shadow:0 6px 20px rgba(0,0,0,0.04)">
    <div style="display:flex;gap:8px;align-items:center;">
      <h2 style="margin:0 8px 8px 0;">How to use / Readme</h2>
      <div style="margin-left:auto;display:flex;gap:8px">
        <button id="readmeLangBtn" class="small-btn" style="background:#f3f4f6;border:1px solid #e5e7eb">हिन्दी</button>
        <button id="readmeEngBtn" class="small-btn" style="background:#f3f4f6;border:1px solid #e5e7eb">English</button>
      </div>
    </div>

    <div id="readmeContent" style="margin-top:12px;line-height:1.6;color:#333"></div>

    <div class="badge-row" aria-hidden="true">
      <!-- Trusted badges requested to be in readme -->
      <div class="badge">Free • No cost</div>
      <div class="badge">Privacy-first • Client-side</div>
      <div class="badge">Supports HEIC/HEIF • JPEG • PNG • WEBP • AVIF</div>
      <div class="badge">PWA • Offline Capable</div>
    </div>

    <hr style="margin:16px 0;border:none;border-top:1px solid #eee">
    <h3 style="margin:0 0 8px 0">Compare & Why choose Smart Cam Scanner</h3>
    <p style="margin:0 0 12px 0">
      Compared with popular apps (CamScanner, Adobe Scan, Google Drive scan), Smart Cam Scanner focuses on being:
      <strong>fast, privacy-first (all processing client-side), lightweight PWA, accepts modern formats (HEIC/AVIF), and provides high-quality adaptive B/W</strong>.
    </p>

    <h4 style="margin:8px 0 6px 0">Features</h4>
    <ul>
      <li>Smart Auto Crop & Perspective Fix</li>
      <li>Adaptive B/W tuned for document clarity (less crushed blacks)</li>
      <li>Merge multiple images to single PDF</li>
      <li>Save images in JPEG/PNG/WEBP (browser support) — HEIC best-effort for input, exported as JPEG/PNG/WEBP where supported.</li>
      <li>PWA installable & works offline for core features</li>
    </ul>

    <div style="margin-top:12px;color:#666;font-size:13px">Feedback / Support inside footer button or email: <a href="mailto:skycommunics@gmail.com">skycommunics@gmail.com</a></div>
  </section>

  <!-- footer with blue feedback button -->
  <footer>
    <div style="margin-bottom:8px;">
      <a class="fb-feedback" href="mailto:skycommunics@gmail.com">Feedback</a>
    </div>
    <div style="color:#999">© <a href="https://skycommunics.com" target="_blank" rel="noopener">skycommunics.com</a> — Smart Cam Scanner</div>
  </footer>

<!-- REPLACE ONLY THE CONTENTS OF YOUR <script> ... </script> WITH THIS BLOCK -->
<script>
/* ================= CONFIG ================= */
const PREVIEW_MAX_SIDE = 1500;
const PREVIEW_DETECT_SIDE = 800;
const PREVIEW_JPEG_QUALITY = 0.92;
const MERGE_TARGET_WIDTH = 1200;

/* ================= STATE ================= */
let originals = [];       // full-res dataURLs OR fallback jpeg data URLs
let originalsFiles = [];  // original File objects (if available)
let previews = [];        // preview dataURLs (may be null)
let uiPreview = [];       // preview after showing filters (not modifying originals until save)
let grayscaleFlags = [];
let bwFlags = [];
let transforms = [];
let currentIndex = null;

/* ================= ELEMENTS ================= */
const nativeCam = document.getElementById('nativeCam');
const pick = document.getElementById('pick');
const tip = document.getElementById('tip');
const thumbs = document.getElementById('thumbs');
const actions = document.getElementById('actions');
const savePDF = document.getElementById('savePDF');
const saveImages = document.getElementById('saveImages');
const saveMerged = document.getElementById('saveMerged');
const imgFormat = document.getElementById('imgFormat');
const clearAll = document.getElementById('clearAll');
const moreTools = document.getElementById('moreTools');

const cropModal = document.getElementById('cropModal');
const cropImage = document.getElementById('cropImage');
const cropSVG = document.getElementById('cropSVG');
const cropToggle = document.getElementById('cropToggle');
const rotateBtn = document.getElementById('rotateBtn');
const applyGray = document.getElementById('applyGray');
const applyBW = document.getElementById('applyBW');
const bwRange = document.getElementById('bwRange');
const origBtn = document.getElementById('origBtn');
const saveBtn = document.getElementById('saveBtn');
const cropCancel = document.getElementById('cropCancel');
const installBtn = document.getElementById('installBtn');

const readmeContent = document.getElementById('readmeContent');
const readmeLangBtn = document.getElementById('readmeLangBtn');
const readmeEngBtn = document.getElementById('readmeEngBtn');

/* ================= HELPERS ================= */
function el(tag, props={}){ const e=document.createElement(tag); Object.assign(e,props); return e; }
function sleep(ms){ return new Promise(r=>setTimeout(r,ms)); }

// load image from dataURL (normal path)
function loadImage(dataURL){
  return new Promise((res,rej)=>{
    const i=new Image();
    i.crossOrigin='anonymous';
    i.onload=()=>res(i);
    i.onerror=err=>rej(err);
    i.src=dataURL;
  });
}

function dataURLtoBlob(dataurl){
  const arr=dataurl.split(',');
  const mime = arr[0].match(/:(.*?);/)[1];
  const bstr=atob(arr[1]);
  let n=bstr.length;
  const u8=new Uint8Array(n);
  while(n--) u8[n]=bstr.charCodeAt(n);
  return new Blob([u8],{type:mime});
}

/* fix exif orientation (works only on images decodable by Image) */
async function fixOrientationDataURL(dataURL){
  try{
    if(!dataURL || !dataURL.startsWith('data:')) return dataURL;
    const base64 = dataURL.split(',')[1];
    const binary = atob(base64);
    const len = binary.length;
    const buffer = new ArrayBuffer(len);
    const view = new Uint8Array(buffer);
    for(let i=0;i<len;i++) view[i]=binary.charCodeAt(i);
    let orientation = 1;
    try{ const tags = EXIF.readFromBinaryFile(view.buffer); if(tags&&tags.Orientation) orientation=tags.Orientation; }catch(e){ orientation=1; }
    if(!orientation || orientation===1) return dataURL;
    const img = await loadImage(dataURL);
    const canvas = document.createElement('canvas'), ctx=canvas.getContext('2d');
    if(orientation>4){ canvas.width=img.height; canvas.height=img.width; } else { canvas.width=img.width; canvas.height=img.height; }
    switch(orientation){
      case 2: ctx.translate(canvas.width,0); ctx.scale(-1,1); break;
      case 3: ctx.translate(canvas.width,canvas.height); ctx.rotate(Math.PI); break;
      case 4: ctx.translate(0,canvas.height); ctx.scale(1,-1); break;
      case 5: ctx.rotate(0.5*Math.PI); ctx.scale(1,-1); ctx.drawImage(img,0,-img.height); return canvas.toDataURL('image/jpeg',0.95);
      case 6: ctx.rotate(0.5*Math.PI); ctx.translate(0,-canvas.width); break;
      case 7: ctx.rotate(0.5*Math.PI); ctx.translate(canvas.height,-canvas.width); ctx.scale(-1,1); break;
      case 8: ctx.rotate(-0.5*Math.PI); ctx.translate(-canvas.height,0); break;
      default: break;
    }
    ctx.drawImage(img,0,0);
    return canvas.toDataURL('image/jpeg',0.95);
  }catch(e){ return dataURL; }
}

/* make a preview (resizes) from an Image element or ImageBitmap */
async function makePreviewFromImageElement(img){
  const maxSide = PREVIEW_MAX_SIDE;
  const scale = Math.max(1, Math.ceil(Math.max(img.width,img.height)/maxSide));
  const w = Math.floor(img.width/scale), h = Math.floor(img.height/scale);
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,c.width,c.height);
  ctx.drawImage(img,0,0,w,h);
  return c.toDataURL('image/jpeg',PREVIEW_JPEG_QUALITY);
}

async function makePreviewFromImageBitmap(bitmap){
  const maxSide = PREVIEW_MAX_SIDE;
  const scale = Math.max(1, Math.ceil(Math.max(bitmap.width,bitmap.height)/maxSide));
  const w = Math.floor(bitmap.width/scale), h = Math.floor(bitmap.height/scale);
  const c = document.createElement('canvas'); c.width=w; c.height=h;
  const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,c.width,c.height);
  ctx.drawImage(bitmap,0,0,w,h);
  return c.toDataURL('image/jpeg',PREVIEW_JPEG_QUALITY);
}

/* high-level: generate preview from a File (tries createImageBitmap first, and heic2any for HEIC/HEIF) */
async function generatePreviewFromFile(file){
  const type = (file.type||'').toLowerCase();
  // HEIC/HEIF: use heic2any to convert to JPEG/PNG Blob first (heic2any uses WASM)
  if(type.includes('heic') || type.includes('heif')){
    if(typeof heic2any === 'undefined'){
      console.warn('heic2any not loaded; cannot decode HEIC here.');
      return null;
    }
    try{
      const converted = await heic2any({blob: file, toType: "image/jpeg", quality: 0.92});
      const blob = converted instanceof Blob ? converted : (Array.isArray(converted) ? converted[0] : converted);
      if(blob){
        try{
          if(window.createImageBitmap){
            const bm = await createImageBitmap(blob);
            const prev = await makePreviewFromImageBitmap(bm);
            bm.close && bm.close();
            return prev;
          }
        }catch(e){}
        const data = await new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.readAsDataURL(blob); });
        try{ const img = await loadImage(data); return await makePreviewFromImageElement(img); }catch(e){ return data; }
      }
      return null;
    }catch(err){
      console.warn('HEIC decode failed', err);
      return null;
    }
  }

  // Try createImageBitmap for many image types (AVIF included on supporting browsers)
  try{
    if(window.createImageBitmap){
      const bm = await createImageBitmap(file);
      const prev = await makePreviewFromImageBitmap(bm);
      bm.close && bm.close();
      return prev;
    }
  }catch(e){
    // fall back
  }

  // Try FileReader + Image
  try{
    const data = await new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.readAsDataURL(file); });
    try{
      const img = await loadImage(data);
      const fixed = await fixOrientationDataURL(data).catch(_=>data);
      const prev = await makePreviewFromImageElement(img).catch(_=>fixed);
      return prev;
    }catch(e){
      return null;
    }
  }catch(e){
    return null;
  }
}

/* ====== RENDER THUMBS ====== */
function renderThumbs(){
  thumbs.innerHTML='';
  uiPreview.forEach((src,i)=>{
    const box = el('div',{className:'thumb-box'});
    if(src){
      const img = el('img',{className:'thumb',src, alt:`image ${i+1}`});
      img.addEventListener('click', ()=> openCrop(i));
      box.appendChild(img);
    } else {
      const ph = el('div',{className:'thumb-placeholder', innerHTML: `<div>Preview not supported<br/><small>Tap to open editor</small></div>`});
      ph.addEventListener('click', ()=> openCrop(i));
      box.appendChild(ph);
    }
    const rm = el('button',{className:'remove-btn',innerText:'×',title:'Remove'});
    rm.addEventListener('click', ev=>{ ev.stopPropagation(); originals.splice(i,1); originalsFiles.splice(i,1); previews.splice(i,1); uiPreview.splice(i,1); grayscaleFlags.splice(i,1); bwFlags.splice(i,1); transforms.splice(i,1); renderThumbs(); });
    const ml = el('button',{className:'move-left',innerText:'◀',title:'Move left'}); ml.addEventListener('click', ev=>{ ev.stopPropagation(); if(i>0) swap(i,i-1); });
    const mr = el('button',{className:'move-right',innerText:'▶',title:'Move right'}); mr.addEventListener('click', ev=>{ ev.stopPropagation(); if(i<uiPreview.length-1) swap(i,i+1); });
    box.appendChild(rm); box.appendChild(ml); box.appendChild(mr); thumbs.appendChild(box);
  });
  actions.style.display = uiPreview.length ? 'block' : 'none';
}
function swap(a,b){
  [originals[a],originals[b]]=[originals[b],originals[a]];
  [originalsFiles[a],originalsFiles[b]]=[originalsFiles[b],originalsFiles[a]];
  [previews[a],previews[b]]=[previews[b],previews[a]];
  [uiPreview[a],uiPreview[b]]=[uiPreview[b],uiPreview[a]];
  [grayscaleFlags[a],grayscaleFlags[b]]=[grayscaleFlags[b],grayscaleFlags[a]];
  [bwFlags[a],bwFlags[b]]=[bwFlags[b],bwFlags[a]];
  [transforms[a],transforms[b]]=[transforms[b],transforms[a]];
  renderThumbs();
}

/* ====== INPUT HANDLERS ====== */
// forward clicks on labels to input (fixes double-click device issue)
document.getElementById('cameraBtn').addEventListener('click', ()=> nativeCam.click());
document.getElementById('galleryBtn').addEventListener('click', ()=> pick.click());

nativeCam.addEventListener('change', async e=>{
  if(tip) tip.style.display='none';
  const files = Array.from(e.target.files||[]);
  for(const f of files){
    originalsFiles.push(f);
    const prev = await generatePreviewFromFile(f);
    let dataURL = null;
    try{ dataURL = await new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.readAsDataURL(f); }); }catch(e){ dataURL = null; }
    originals.push(dataURL || prev || '');
    previews.push(prev);
    uiPreview.push(prev);
    grayscaleFlags.push(false);
    bwFlags.push(false);
    transforms.push(null);
    renderThumbs();
    await sleep(30);
  }
  nativeCam.value='';
});

pick.addEventListener('change', async e=>{
  if(tip) tip.style.display='none';
  const files = Array.from(e.target.files||[]);
  for(const f of files){
    originalsFiles.push(f);
    const prev = await generatePreviewFromFile(f);
    let dataURL = null;
    try{ dataURL = await new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.readAsDataURL(f); }); }catch(e){ dataURL = null; }
    originals.push(dataURL || prev || '');
    previews.push(prev);
    uiPreview.push(prev);
    grayscaleFlags.push(false);
    bwFlags.push(false);
    transforms.push(null);
    renderThumbs();
    await sleep(30);
  }
  pick.value='';
});

clearAll.addEventListener('click', ()=>{ originals=[];originalsFiles=[];previews=[];uiPreview=[];grayscaleFlags=[];bwFlags=[];transforms=[];renderThumbs(); });

moreTools.addEventListener('click', ()=> window.open('https://skycommunics.com','_blank'));

/* ====== AUTO-DETECT ====== */
async function autoDetectRect(dataURL){
  try{
    if(!dataURL) return [0,0,0,0];
    const img = await loadImage(dataURL);
    const w = img.naturalWidth, h = img.naturalHeight;
    const scale = Math.max(1, Math.floor(Math.max(w,h)/PREVIEW_DETECT_SIDE));
    const cw = Math.floor(w/scale), ch = Math.floor(h/scale);
    const c = document.createElement('canvas'); c.width=cw; c.height=ch;
    const ctx = c.getContext('2d'); ctx.drawImage(img,0,0,cw,ch);
    const id = ctx.getImageData(0,0,cw,ch).data;
    let minX=cw, minY=ch, maxX=0, maxY=0, found=false;
    for(let y=0;y<ch;y++){
      for(let x=0;x<cw;x++){
        const i=(y*cw+x)*4; const r=id[i],g=id[i+1],b=id[i+2];
        const lum = 0.2126*r + 0.7152*g + 0.0722*b;
        if(lum < 245){ found=true; if(x<minX) minX=x; if(x>maxX) maxX=x; if(y<minY) minY=y; if(y>maxY) maxY=y; }
      }
    }
    if(!found) return [0,0,w,h];
    const pad = Math.round(8*(Math.max(w,h)/1000));
    const rminX = Math.max(0, Math.floor(minX*scale - pad));
    const rminY = Math.max(0, Math.floor(minY*scale - pad));
    const rmaxX = Math.min(w, Math.ceil((maxX+1)*scale + pad));
    const rmaxY = Math.min(h, Math.ceil((maxY+1)*scale + pad));
    return [rminX, rminY, rmaxX, rmaxY];
  }catch(e){
    return [0,0,0,0];
  }
}

/* ====== HOMOGRAPHY & WARP ====== */
// ... keep the same computeHomography, invertHomography, warpImageWithHomography functions ...
// (unchanged from original, omitted here for brevity in this snippet — keep them as in your existing file)

/* ====== CROP UI (SVG) ====== */
// (keep SVG crop code unchanged — omitted here for brevity in this snippet)

/* We'll continue with key changed functions: performCrop, rotate flow, export flows and spinner helper */

/* ----- Spinner helper (creates a small high-contrast spinner next to a button) ----- */
function showSpinnerForButton(btn){
  if(!btn) return null;
  // don't create duplicate
  if(btn._spinner) return btn._spinner;
  const spinner = document.createElement('span');
  spinner.className = 'dynamic-spinner';
  // visible high-contrast styling
  spinner.style.display = 'inline-block';
  spinner.style.width = '18px';
  spinner.style.height = '18px';
  spinner.style.marginLeft = '8px';
  spinner.style.borderRadius = '50%';
  spinner.style.border = '3px solid rgba(255,255,255,0.15)'; // light border
  spinner.style.borderTop = '3px solid #ffffff'; // bright top for contrast
  spinner.style.boxSizing = 'border-box';
  spinner.style.verticalAlign = 'middle';
  spinner.style.animation = 'spin 1s linear infinite';
  // darker outline if button background is light
  spinner.style.filter = 'drop-shadow(0 0 3px rgba(0,0,0,0.25))';
  btn.parentNode && btn.parentNode.insertBefore(spinner, btn.nextSibling);
  btn._spinner = spinner;
  return spinner;
}
function hideSpinnerForButton(btn){
  if(!btn || !btn._spinner) return;
  try{ btn._spinner.remove(); }catch(e){}
  delete btn._spinner;
}

/* add simple keyframes (inject once) */
(function addSpinnerKeyframes(){
  if(document.getElementById('dynamic-spinner-style')) return;
  const s = document.createElement('style'); s.id='dynamic-spinner-style';
  s.innerHTML = `@keyframes spin{ from{ transform: rotate(0deg);} to{ transform: rotate(360deg);} } .dynamic-spinner{display:inline-block}`;
  document.head.appendChild(s);
})();

/* ====== PERFORM CROP (MODIFIED: keep modal open after Save Crop) ====== */
async function performCrop(idx){
  if(idx===null || idx<0) return;
  let origData = originals[idx] || previews[idx] || '';
  if((!origData || origData.length===0) && originalsFiles[idx]){
    origData = await rasterizeFileToDataURL(originalsFiles[idx], 'image/jpeg', 0.95).catch(_=>null);
    if(origData){
      // ensure orientation fixed for rasterized result
      origData = await fixOrientationDataURL(origData).catch(_=>origData);
      originals[idx] = origData;
    }
  }
  if(!origData){
    alert('Crop not available for this file because preview/decoding is not supported in your browser.');
    return;
  }

  const origImg = await loadImage(origData);
  const ow = origImg.width, oh = origImg.height;
  const prevImg = await loadImage(previews[idx] || origData).catch(_=>null);
  if(!prevImg){
    const srcPts = [{x:0,y:0},{x:ow,y:0},{x:ow,y:oh},{x:0,y:oh}];
    const outW = ow, outH = oh;
    saveBtn.disabled = true;
    const spinner = showSpinnerForButton(saveBtn);
    const warped = await warpImageWithHomography(origData, srcPts, outW, outH);
    hideSpinnerForButton(saveBtn);
    saveBtn.disabled = false;
    if(warped){
      originals[idx] = warped;
      const newPrev = await makePreviewFromImageElement(await loadImage(warped));
      previews[idx] = newPrev;
      uiPreview[idx] = newPrev;
      renderThumbs();
    }
    return;
  }

  const pw = prevImg.naturalWidth, ph = prevImg.naturalHeight;
  const scaleX = ow / pw, scaleY = oh / ph;
  const srcPts = P.map(pt=>({x: Math.round(pt.x * scaleX), y: Math.round(pt.y * scaleY)}));
  const topW = Math.hypot(srcPts[1].x - srcPts[0].x, srcPts[1].y - srcPts[0].y);
  const rightH = Math.hypot(srcPts[2].x - srcPts[1].x, srcPts[2].y - srcPts[1].y);
  const outW = Math.max(200, Math.round(topW));
  const outH = Math.max(200, Math.round(rightH));

  // show spinner and disable save button while cropping
  saveBtn.innerText = 'Cropping...';
  saveBtn.disabled = true;
  const spinner = showSpinnerForButton(saveBtn);

  const warped = await warpImageWithHomography(origData, srcPts, outW, outH);

  hideSpinnerForButton(saveBtn);
  saveBtn.disabled = false;
  saveBtn.innerText = 'Save';

  if(!warped){ alert('Crop failed — try again'); return; }

  originals[idx] = warped;
  const newPrev = await makePreviewFromImageElement(await loadImage(warped));
  previews[idx] = newPrev;
  uiPreview[idx] = newPrev;
  grayscaleFlags[idx]=false; bwFlags[idx]=false;
  renderThumbs();

  // IMPORTANT CHANGE:
  // After Save Crop, keep the crop modal OPEN and show updated image so user can continue editing.
  cropImage.src = uiPreview[idx] || previews[idx] || originals[idx] || '';
  cropImage.onload = ()=>{ svgW = cropImage.naturalWidth; svgH = cropImage.naturalHeight; createSVG(svgW,svgH); P=[{x:0,y:0},{x:svgW,y:0},{x:svgW,y:svgH},{x:0,y:svgH}]; drawCrop(); hideCrop(); };
  // do NOT call closeCropModal() here — let user continue editing
}

/* ====== applyFinalFiltersToOriginal (unchanged except orientation fix for raster fallback) ====== */
async function applyFinalFiltersToOriginal(i){
  if(i===null) return;
  let data = originals[i];
  if(!data && originalsFiles[i]){
    data = await rasterizeFileToDataURL(originalsFiles[i], 'image/jpeg', 0.92).catch(_=>null);
    if(data){
      data = await fixOrientationDataURL(data).catch(_=>data);
    }
  }
  if(!data) return;
  if(grayscaleFlags[i]) data = await applyGrayPreviewDataURL(data);
  if(bwFlags[i]) {
    const k = getKFromSlider();
    data = await applyAdaptiveBWPreviewAndHQ(data, 1000, 25, k);
  }
  originals[i] = data;
  const newPrev = await makePreviewFromImageElement(await loadImage(data));
  previews[i] = newPrev;
  uiPreview[i] = newPrev;
  grayscaleFlags[i] = false; bwFlags[i] = false;
  renderThumbs();
}

/* ====== rotateDataURL (unchanged) ====== */
async function rotateDataURL(dataURL){
  try{
    const img = await loadImage(dataURL);
    const c = document.createElement('canvas'); c.width=img.height; c.height=img.width;
    const ctx = c.getContext('2d'); ctx.translate(c.width/2,c.height/2); ctx.rotate(Math.PI/2); ctx.drawImage(img,-img.width/2,-img.height/2);
    return c.toDataURL('image/jpeg',0.95);
  }catch(e){
    return null;
  }
}

/* ====== Rasterize file (unchanged except we ensure fixOrientation when producing dataURL) ====== */
async function rasterizeFileToDataURL(file, mime='image/jpeg', quality=0.92){
  const type = (file.type||'').toLowerCase();
  if((type.includes('heic') || type.includes('heif')) && typeof heic2any !== 'undefined'){
    try{
      const converted = await heic2any({blob: file, toType: mime, quality: quality});
      const blob = converted instanceof Blob ? converted : (Array.isArray(converted) ? converted[0] : converted);
      if(blob){
        const data = await new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.readAsDataURL(blob); });
        return await fixOrientationDataURL(data).catch(_=>data);
      }
    }catch(e){}
  }

  try{
    if(window.createImageBitmap){
      const bm = await createImageBitmap(file);
      const c = document.createElement('canvas'); c.width = bm.width; c.height = bm.height;
      const ctx = c.getContext('2d'); ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,c.width,c.height);
      ctx.drawImage(bm,0,0);
      bm.close && bm.close();
      const data = c.toDataURL(mime, quality);
      return await fixOrientationDataURL(data).catch(_=>data);
    }
  }catch(e){}

  try{
    const data = await new Promise(res=>{ const fr=new FileReader(); fr.onload=()=>res(fr.result); fr.readAsDataURL(file); });
    const img = await loadImage(data);
    const canvas = document.createElement('canvas'); canvas.width=img.width; canvas.height=img.height;
    const ctx = canvas.getContext('2d'); ctx.fillStyle='#ffffff'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.drawImage(img,0,0);
    const out = canvas.toDataURL(mime, quality);
    return await fixOrientationDataURL(out).catch(_=>out);
  }catch(e){
    return null;
  }
}

/* ====== buildCanvasFromDataURL (unchanged) ====== */
async function buildCanvasFromDataURL(dataURL){
  const img = await loadImage(dataURL);
  const c = document.createElement('canvas');
  c.width = img.width;
  c.height = img.height;
  const ctx = c.getContext('2d');
  ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,c.width,c.height);
  ctx.drawImage(img,0,0);
  return c;
}

/* ====== formatToMime (remove AVIF output support per earlier request) ====== */
function formatToMime(format){
  format = (format||'jpeg').toLowerCase();
  switch(format){
    case 'jpeg': case 'jpg': return 'image/jpeg';
    case 'png': return 'image/png';
    case 'webp': return 'image/webp';
    default: return 'image/jpeg';
  }
}

/* ====== download helper ====== */
function downloadDataURL(dataURL, filename){
  const a = document.createElement('a');
  a.href = dataURL;
  a.download = filename;
  a.click();
}

/* ====== saveImages (modified to use spinner & orientation fix) ====== */
saveImages.addEventListener('click', async ()=>{
  if(!originals.length){ alert('No images'); return; }
  const fmt = (imgFormat.value || 'jpeg').toLowerCase();
  const mime = formatToMime(fmt);

  // show spinner on button
  saveImages.disabled = true;
  const sp = showSpinnerForButton(saveImages);

  for(let i=0;i<originals.length;i++){
    const origData = originals[i];
    const file = originalsFiles[i];
    let canvas = null;
    // prefer to rasterize from File
    if(file){
      const raster = await rasterizeFileToDataURL(file, mime, 0.92).catch(_=>null);
      if(raster){
        downloadDataURL(raster, `scan_${i+1}.${fmt}`);
        await sleep(120);
        continue;
      }
    }
    const src = origData || previews[i];
    if(!src){
      alert(`Cannot export page ${i+1}: decoding not supported in this browser.`);
      continue;
    }
    try{
      // ensure orientation applied
      const fixed = await fixOrientationDataURL(src).catch(_=>src);
      canvas = await buildCanvasFromDataURL(fixed);
    }catch(e){
      alert(`Failed to prepare image ${i+1}; skipping.`);
      continue;
    }
    let out = await tryExportCanvasAs(canvas, mime, 0.95);
    if(!out){
      out = await tryExportCanvasAs(canvas, 'image/webp',0.95) || await tryExportCanvasAs(canvas, 'image/jpeg', 0.92);
    }
    if(!out){ alert(`Export failed for page ${i+1}.`); continue; }
    let ext = fmt;
    if(!out.startsWith(`data:${mime}`)){
      const actual = out.substring(5, out.indexOf(';'));
      if(actual.includes('jpeg')) ext = 'jpg';
      else if(actual.includes('png')) ext = 'png';
      else if(actual.includes('webp')) ext = 'webp';
      else ext = fmt;
    }
    downloadDataURL(out, `scan_${i+1}.${ext}`);
    await sleep(180);
  }

  hideSpinnerForButton(saveImages);
  saveImages.disabled = false;
});

/* ====== saveMerged (spinner added) ====== */
saveMerged.addEventListener('click', async ()=>{
  if(!originals.length) return;
  saveMerged.disabled = true;
  const sp = showSpinnerForButton(saveMerged);

  const imgs = [];
  let maxW = 0;
  for(let idx=0; idx<originals.length; idx++){
    const d = originals[idx];
    let img;
    if(d){
      try{ img = await loadImage(d); } catch(e){ img = null; }
    }
    if(!img && originalsFiles[idx]){
      const r = await rasterizeFileToDataURL(originalsFiles[idx], 'image/jpeg', 0.95).catch(_=>null);
      if(r) img = await loadImage(r).catch(_=>null);
    }
    if(!img) continue;
    imgs.push(img); maxW = Math.max(maxW, img.width);
  }
  if(!imgs.length){ alert('No decodable images to merge'); hideSpinnerForButton(saveMerged); saveMerged.disabled=false; return; }
  const targetW = Math.min(MERGE_TARGET_WIDTH, maxW);
  const resized = [];
  for(const im of imgs){
    const scaledH = Math.round(im.height * (targetW / im.width));
    const c = document.createElement('canvas'); c.width=targetW; c.height=scaledH;
    const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled=true; ctx.imageSmoothingQuality='high';
    ctx.fillStyle = '#ffffff'; ctx.fillRect(0,0,c.width,c.height);
    ctx.drawImage(im, 0, 0, targetW, scaledH);
    resized.push(c);
  }
  let totalH = resized.reduce((s,c)=>s + c.height, 0);
  const out = document.createElement('canvas'); out.width = targetW; out.height = totalH;
  const outCtx = out.getContext('2d'); outCtx.fillStyle='#ffffff'; outCtx.fillRect(0,0,out.width,out.height);
  let y=0;
  for(const c of resized){ outCtx.drawImage(c,0,y); y+=c.height; }
  const outData = out.toDataURL('image/jpeg',0.95);
  downloadDataURL(outData, 'merged.jpg');

  hideSpinnerForButton(saveMerged);
  saveMerged.disabled = false;
});

/* ====== savePDF (MODIFIED: ensure orientation fixed before adding to PDF, spinner & disabled state) ====== */
savePDF.addEventListener('click', async ()=>{
  if(!originals.length){ alert('No images'); return; }
  savePDF.disabled = true;
  const sp = showSpinnerForButton(savePDF);

  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({ unit:'pt', format:'a4' });
  const W = 595.28, H = 841.89;

  for(let i=0;i<originals.length;i++){
    let raster = null;
    if(originalsFiles[i]){
      raster = await rasterizeFileToDataURL(originalsFiles[i], 'image/jpeg', 0.92).catch(_=>null);
    }
    if(!raster) raster = originals[i] || previews[i];

    if(!raster){
      alert(`Skipping page ${i+1}: cannot decode image for PDF.`);
      continue;
    }

    // IMPORTANT: normalize orientation to avoid mobile EXIF rotate/stretch issues
    raster = await fixOrientationDataURL(raster).catch(_=>raster);

    const img = await loadImage(raster);
    // compute scale to fit A4 *without* flipping orientation
    let ratio = Math.min(W / img.width, H / img.height);
    // if image is extremely tall or wide, ratio handles it. keep aspect ratio.
    const w = img.width * ratio, h = img.height * ratio;
    const x = (W - w) / 2, y = (H - h) / 2;
    if(i>0) pdf.addPage();
    // always pass raster as JPEG; jsPDF will accept the data URL
    pdf.addImage(raster, 'JPEG', x, y, w, h);
  }

  pdf.save('document.pdf');

  hideSpinnerForButton(savePDF);
  savePDF.disabled = false;
});

/* ====== remaining UI wiring (crop modal open/close, rotate, filters, save/cancel) ====== */
/* NOTE: cropToggle and saveBtn flows updated to match performCrop behavior (saveBtn will close modal) */

let cropVisible = false;
function showCrop(){ cropVisible = true; drawCrop(); cropSVG.style.display = "block"; cropModal.style.display='flex'; cropModal.setAttribute('aria-hidden','false'); cropToggle.innerText = 'Save Crop'; }
function hideCrop(){ cropVisible = false; cropSVG.style.display = "none"; cropToggle.innerText = 'Crop'; }

async function openCrop(i){
  currentIndex = i;
  const previewSrc = uiPreview[i] || previews[i] || originals[i] || null;
  if(previewSrc){
    try{ cropImage.src = previewSrc; }catch(e){ cropImage.src = ''; }
  } else {
    cropImage.src = 'data:image/svg+xml;utf8,' + encodeURIComponent('<svg xmlns="http://www.w3.org/2000/svg" width="600" height="800"><rect width="100%" height="100%" fill="#111"/><text x="50%" y="50%" fill="#fff" font-size="20" text-anchor="middle">Preview not supported</text></svg>');
  }
  cropModal.style.display = 'flex';
  cropModal.setAttribute('aria-hidden','false');
  cropVisible = false;
  cropToggle.innerText = 'Crop';
  cropImage.onload = async ()=>{
    svgW = cropImage.naturalWidth;
    svgH = cropImage.naturalHeight;
    createSVG(svgW, svgH);
    const [ax,ay,bx,by] = await autoDetectRect(previews[i] || originals[i]);
    const safeAx = (ax||0); const safeAy = (ay||0); const safeBx = (bx||svgW); const safeBy = (by||svgH);
    P = [{x:safeAx,y:safeAy},{x:safeBx,y:safeAy},{x:safeBx,y:safeBy},{x:safeAx,y:safeBy}];
    drawCrop();
    hideCrop();
  };
}

function closeCropModal(){ cropModal.style.display = 'none'; cropModal.setAttribute('aria-hidden','true'); currentIndex = null; hideCrop(); }

/* cropToggle: Crop -> (user edits polygon) -> Save Crop (performCrop but keep modal open) */
cropToggle.addEventListener('click', async ()=>{
  if(!Number.isInteger(currentIndex)) return;
  if(!cropVisible){
    showCrop();
  } else {
    // Save Crop but stay in editor so user can continue further edits
    await performCrop(currentIndex);
    // updated preview already applied by performCrop; UI shows updated image and crop region reset
    // do not close modal here
  }
});

cropCancel.addEventListener('click', ()=>{ closeCropModal(); });

rotateBtn.addEventListener('click', async ()=>{
  if(currentIndex===null) return;
  const i = currentIndex;
  saveBtn.disabled = true;
  const spinner = showSpinnerForButton(saveBtn);
  // attempt rotate existing decoded original
  let rotated = null;
  if(originals[i]){
    rotated = await rotateDataURL(originals[i]).catch(_=>null);
  }
  if(!rotated && originalsFiles[i]){
    const r = await rasterizeFileToDataURL(originalsFiles[i], 'image/jpeg', 0.92).catch(_=>null);
    if(r) rotated = await rotateDataURL(r).catch(_=>null);
  }
  if(!rotated){
    hideSpinnerForButton(saveBtn);
    saveBtn.disabled = false;
    alert('Rotate failed for this file (unsupported format).');
    return;
  }
  // set rotated image as original and update previews
  originals[i] = rotated;
  const prev = await makePreviewFromImageElement(await loadImage(rotated));
  previews[i] = prev;
  uiPreview[i] = prev;
  renderThumbs();
  cropImage.src = uiPreview[i];
  cropImage.onload = ()=>{ svgW = cropImage.naturalWidth; svgH = cropImage.naturalHeight; createSVG(svgW,svgH); P=[{x:0,y:0},{x:svgW,y:0},{x:svgW,y:svgH},{x:0,y:svgH}]; drawCrop(); hideCrop(); };
  hideSpinnerForButton(saveBtn);
  saveBtn.disabled = false;
});

applyGray.addEventListener('click', async ()=>{
  if(currentIndex===null) return;
  const i = currentIndex;
  grayscaleFlags[i] = !grayscaleFlags[i];
  bwFlags[i] = false;
  if(grayscaleFlags[i] && previews[i]) uiPreview[i] = await applyGrayPreviewDataURL(previews[i]); else uiPreview[i] = previews[i];
  cropImage.src = uiPreview[i] || originals[i] || '';
  cropImage.onload = ()=>{ svgW = cropImage.naturalWidth; svgH = cropImage.naturalHeight; createSVG(svgW,svgH); drawCrop(); hideCrop(); };
  renderThumbs();
});

applyBW.addEventListener('click', async ()=>{
  if(currentIndex===null) return;
  const i = currentIndex;
  bwFlags[i] = !bwFlags[i];
  grayscaleFlags[i] = false;
  if(bwFlags[i] && previews[i]) uiPreview[i] = await applyBWPreviewDataURL(previews[i]); else uiPreview[i] = previews[i];
  cropImage.src = uiPreview[i] || originals[i] || '';
  cropImage.onload = ()=>{ svgW = cropImage.naturalWidth; svgH = cropImage.naturalHeight; createSVG(svgW,svgH); drawCrop(); hideCrop(); };
  renderThumbs();
});

bwRange.addEventListener('input', async ()=>{
  if(currentIndex===null) return;
  const i = currentIndex;
  if(bwFlags[i] && previews[i]){
    uiPreview[i] = await applyBWPreviewDataURL(previews[i]);
    cropImage.src = uiPreview[i];
    cropImage.onload = ()=>{ svgW = cropImage.naturalWidth; svgH = cropImage.naturalHeight; createSVG(svgW,svgH); drawCrop(); hideCrop(); };
    renderThumbs();
  }
});

origBtn.addEventListener('click', ()=>{
  if(currentIndex===null) return;
  const i = currentIndex;
  grayscaleFlags[i] = false; bwFlags[i] = false;
  uiPreview[i] = previews[i];
  cropImage.src = uiPreview[i] || originals[i] || '';
  cropImage.onload = ()=>{ svgW = cropImage.naturalWidth; svgH = cropImage.naturalHeight; createSVG(svgW,svgH); drawCrop(); hideCrop(); };
  renderThumbs();
});

/* Save (final) button — applies final filters to original and CLOSES modal */
saveBtn.addEventListener('click', async ()=>{
  if(currentIndex===null) { closeCropModal(); return; }
  const btn = saveBtn;
  btn.disabled = true;
  const sp = showSpinnerForButton(btn);
  if(cropVisible){
    // if user left polygon visible and presses Save (final), perform crop first
    await performCrop(currentIndex);
  }
  await applyFinalFiltersToOriginal(currentIndex);
  hideSpinnerForButton(btn);
  btn.disabled = false;
  closeCropModal();
});

/* ====== initial render & readme handling (unchanged) ====== */
renderThumbs();

// PWA register...
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/service-worker.js')
  .then(() => console.log("SW Registered"))
  .catch(err => console.log("SW Failed", err));
}

let deferredPrompt;
window.addEventListener("beforeinstallprompt", (e) => {
    e.preventDefault();
    deferredPrompt = e;
    installBtn.style.display = "inline-block";
});

installBtn.addEventListener("click", async () => {
    if (!deferredPrompt) return;
    deferredPrompt.prompt();
    const choice = await deferredPrompt.userChoice;
    if (choice.outcome === "accepted") {
        installBtn.style.display = "none";
    }
    deferredPrompt = null;
});

const EN_README = `
<h3>How to use Smart Cam Scanner (English)</h3>
<ol>
  <li>Use the <strong>Camera</strong> button to take a photo of your document. Photos appear as thumbnails on the page.</li>
  <li>Use the <strong>Gallery</strong> button to add images saved on your device (JPEG, PNG, WEBP, HEIC/HEIF supported for input).</li>
  <li>Click a thumbnail to open the editor — crop, rotate, apply Grayscale or B/W preview.</li>
  <li>Press <strong>Save</strong> inside the editor to apply changes to the original image (saved as JPEG internally if necessary).</li>
  <li>Use <strong>Save PDF</strong> to convert all images to a single PDF. Use <strong>Merge All</strong> to download merged JPG.</li>
  <li>Use <strong>Save Images</strong> to download individual images in JPEG/PNG/WEBP (browser-dependent support).</li>
  <li>Feedback: <a href='mailto:skycommunics@gmail.com'>skycommunics@gmail.com</a></li>
</ol>
`;
const HI_README = `
<h3>कैसे उपयोग करें — Smart Cam Scanner (हिन्दी)</h3>
<ol>
  <li><strong>Camera</strong> बटन दबाकर अपने दस्तावेज़ की तस्वीर लें — तस्वीरें थंबनेल के रूप में दिखाई देंगी।</li>
  <li><strong>Gallery</strong> बटन से अपने डिवाइस में सेव इमेज (JPEG, PNG, WEBP, HEIC/HEIF) जोड़ें।</li>
  <li>थंबनेल पर क्लिक करने से एडिटर खुलेगा — क्रॉप, रोटेट, Grayscale या B/W preview लागू करें।</li>
  <li>एडिटर में <strong>Save</strong> दबाने पर बदलाव मूल इमेज पर सेव होंगे (जरूरत होने पर JPEG में)।</li>
  <li><strong>Save PDF</strong> दबाने पर सभी इमेज एक PDF में कनवर्ट होकर डाउनलोड होंगी। <strong>Merge All</strong> से एकल JPG बनेगा।</li>
  <li><strong>Save Images</strong> से JPEG/PNG/WEBP में डाउनलोड कर सकते हैं (ब्राउज़र सपोर्ट पर निर्भर)।</li>
  <li>प्रतिक्रिया के लिए मेल: <a href='mailto:skycommunics@gmail.com'>skycommunics@gmail.com</a></li>
</ol>
`;

function setReadme(lang){
  if(lang === 'hi'){ readmeContent.innerHTML = HI_README; readmeLangBtn.style.display='none'; readmeEngBtn.style.display='inline-block'; }
  else { readmeContent.innerHTML = EN_README; readmeEngBtn.style.display='none'; readmeLangBtn.style.display='inline-block'; }
}
setReadme('en');

readmeEngBtn.addEventListener('click', ()=> setReadme('en'));
readmeLangBtn.addEventListener('click', ()=> setReadme('hi'));

/* expose debug hook */
window.openCrop = openCrop;
  </script>
</body>
</html>